% In this script we analyze the augmented motion data, first by introducing
% an ad-hoc IK step, and then by running the muscle redundancy solver on
% them.
% A costum IK is needed since the noise in injected just on the elbow
% markers, thus the scapula needs some regularization of its movements.

close all; clear; clc; beep off;

% Import the OpenSim libraries.
import org.opensim.modeling.*;

% set the path current folder to be the one where this script is contained
mfile_name          = mfilename('fullpath');
[pathstr,~,~]  = fileparts(mfile_name);
cd(pathstr);

% getting path to other folders in this repo
addpath(pathstr)
cd ..\..\..\..\
path_to_repo = pwd;
addpath(path_to_repo)
addpath(fullfile(path_to_repo, 'Code\Data Processing\Matlab\'))

% where to save the results
saving_path = fullfile(path_to_repo, 'Personal_Results\');
% Select the experimental data to be considered
dataset_considered = 'Seth2019';

% Select model
modelFile = fullfile(path_to_repo, '\Personal_Results\TSM_Ajay2019_2kgWeight.osim');
model= Model(modelFile);

% select (noisy) .trc files to consider
[files,path_trc] = uigetfile('*.trc', 'Select the .trc files to analyse', path_to_repo, 'MultiSelect','on');

if iscell(files)
    num_files = size(files, 2);
else
    num_files = 1;
    files = {files};
end

for index_file = 1:num_files
    name_noisy_trc = files{index_file};
    motion_file_name = [extractBefore(files{index_file}, '.trc'), '.mot'];

    % at first iteration, get the time vector (equal for all)
    if index_file==1
        [~, times, ~, ~] = readTRC([path_trc, name_noisy_trc]);
        start_time = times(1);
        end_time = times(end);
    end

    % IK step
    % perform IK on the basis of marker data to retrieve the motion file for
    % the coordinates of the model
    ikSetupFile = fullfile(path_to_repo, '\Personal_Results\IKSetup_2019_analysis_noisy_markers.xml');
    
    % Set the weight for the various scapula coordinates in IK
    % This is to achieve a good scapula movement
    weight_abd = 0.0001;
    weight_elev = 0.0001;
    weight_up_rot = 0.0002;
    weigth_wing = 0.0001;
    
    %% getting the values of default scapula coordinate 
    % we get the values of the coordinates describing the scapula position from 
    % the general model in default pose
    scapula_abd = model.getJointSet().get(2).get_coordinates(0);
    scapula_ele = model.getJointSet().get(2).get_coordinates(1);
    scapula_urt = model.getJointSet().get(2).get_coordinates(2);
    scapula_wng = model.getJointSet().get(2).get_coordinates(3);
    
    default_sa = scapula_abd.get_default_value();
    default_se = scapula_ele.get_default_value();
    default_su = scapula_urt.get_default_value();
    default_sw = scapula_wng.get_default_value();
    
    ikTool = InverseKinematicsTool(ikSetupFile);
    ikTool.setMarkerDataFileName([path_trc, name_noisy_trc]);
    ikTool.setOutputMotionFileName([saving_path, motion_file_name]);
    ikTool.set_report_marker_locations(1);
    ikTool.setStartTime(start_time);
    ikTool.setEndTime(end_time);
    ikTool.setModel(model);
    
    % set the reference values for the scapula coordinates (last 4 tasks)
    num_IK_tasks = ikTool.getIKTaskSet.getSize();
    
    % set the weight of each coordinate in the tracking tasks
    ikTool.getIKTaskSet.get(num_IK_tasks-4).setWeight(weight_abd);
    ikTool.getIKTaskSet.get(num_IK_tasks-3).setWeight(weight_elev);
    ikTool.getIKTaskSet.get(num_IK_tasks-2).setWeight(weight_up_rot);
    ikTool.getIKTaskSet.get(num_IK_tasks-1).setWeight(weigth_wing);
    
    % set also the values here
    IKCoordinateTask.safeDownCast(ikTool.getIKTaskSet.get(num_IK_tasks-4)).setValue(default_sa);
    IKCoordinateTask.safeDownCast(ikTool.getIKTaskSet.get(num_IK_tasks-3)).setValue(default_se);
    IKCoordinateTask.safeDownCast(ikTool.getIKTaskSet.get(num_IK_tasks-2)).setValue(default_su);
    IKCoordinateTask.safeDownCast(ikTool.getIKTaskSet.get(num_IK_tasks-1)).setValue(default_sw);
    ikTool.print('SO_autogenerated_IK_setup.xml');
    
    ikTool.run();
end

%% RMR solver

% Downsampling
time_interval = 1;

% Flags (Select whether to enforce constraint 3 and 4 from the formulation
% reported in the paper)
dynamic_bounds = true;
enforce_GH_constraint = false;

%% Run Muscle Redundancy Solver (MRS)
% preallocating arrays to hold information about the solutions
optimizationStatus = [];
unfeasibility_flag = [];
tOptim = zeros(num_files,1);
result_file_MRS = {};



for index_file=1:num_files
    fprintf('Running MRS on experiment %i \n', index_file)
    motion_file_name = [extractBefore(files{index_file}, '.trc'), '.mot'];
    [aux_optimization_status, aux_unfeasibility_flags, tOptim(index_file), aux_result_file] = MRS_analysis(dataset_considered, ...
                                                                                                                  model, ...
                                                                                                                  [], ...
                                                                                                                  motion_file_name, ...
                                                                                                                  [], ...
                                                                                                                  time_interval, ...
                                                                                                                  dynamic_bounds, ...
                                                                                                                  enforce_GH_constraint, ...
                                                                                                                  saving_path);
    optimizationStatus(index_file).experiment = aux_optimization_status;
    result_file_MRS{index_file} = aux_result_file;
    unfeasibility_flag(index_file).experiment = aux_unfeasibility_flags;
    fprintf('\n Solved with %i unfeasible solutions \n \n \n', sum(aux_unfeasibility_flags));
end
